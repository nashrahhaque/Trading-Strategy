# -*- coding: utf-8 -*-
"""finance.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16pM-FCYWcWlpFFtUXQ-Qmmfnga5O_r0X
"""

!pip install yfinance matplotlib pandas numpy

import yfinance as yf
import pandas as pd

# Define tickers (you can choose others too)
tickers = ['AAPL', 'MSFT']

# Fetch historical stock data
data = yf.download(tickers, start='2015-01-01', end='2023-10-01')['Adj Close']

# Preview the data
data.head()

# Calculate short-term (20-day) and long-term (50-day) moving averages
data['MA10'] = data['AAPL'].rolling(window=10).mean()
data['MA30'] = data['AAPL'].rolling(window=30).mean()

# Preview the moving averages
data[['AAPL', 'MA10', 'MA30']].tail()

data['MA20'] = data['AAPL'].rolling(window=10).mean()
data[['AAPL', 'MA10']].tail()

data['MA50'] = data['AAPL'].rolling(window=30).mean()
data[['AAPL', 'MA30']].tail()

import numpy as np

data['Signal'] = 0  # Initialize with 0 (no action)
data['Signal'][10:] = np.where(data['MA10'][10:] > data['MA30'][10:], 1, 0)
data[['AAPL', 'MA10', 'MA30', 'Signal']].tail()

# Calculate the position based on changes in the Signal
data['Position'] = data['Signal'].diff()

# Check the positions
print(data[['AAPL', 'Signal', 'Position']].tail())  # Preview signal and position data

import matplotlib.pyplot as plt
# Plot stock price and moving averages
plt.figure(figsize=(12,6))
plt.plot(data['AAPL'], label='AAPL Price', alpha=0.5)
plt.plot(data['MA10'], label='10-Day MA', alpha=0.75)
plt.plot(data['MA30'], label='30-Day MA', alpha=0.75)
plt.legend()
plt.title('AAPL Stock Price with Moving Averages')
plt.show()



print(data['Signal'].value_counts())  # Check the number of Buy signals (1s) and No signals (0s)

# Calculate daily returns for AAPL stock
data['Market Return'] = data['AAPL'].pct_change()

# Calculate strategy returns based on the position (shifted by 1 day to simulate action after signal)
data['Strategy Return'] = data['Market Return'] * data['Position'].shift(1)

print(data[['Market Return', 'Strategy Return']].head())

# Calculate cumulative returns for both the market and the strategy
data['Market Cumulative Return'] = (1 + data['Market Return']).cumprod()
data['Strategy Cumulative Return'] = (1 + data['Strategy Return']).cumprod()

import numpy as np

# Calculate annualized volatility (standard deviation) for both the market and your strategy
market_volatility = data['Market Return'].std() * np.sqrt(252)
strategy_volatility = data['Strategy Return'].std() * np.sqrt(252)

# Print the results
print(f"Market Volatility: {market_volatility}")
print(f"Strategy Volatility: {strategy_volatility}")

# Assume the risk-free rate is 0 for simplicity (you can adjust this if needed)
risk_free_rate = 0.0

# Calculate Sharpe Ratio for the market and the strategy
market_sharpe = (data['Market Return'].mean() - risk_free_rate) / data['Market Return'].std() * np.sqrt(252)
strategy_sharpe = (data['Strategy Return'].mean() - risk_free_rate) / data['Strategy Return'].std() * np.sqrt(252)

# Print the results
print(f"Market Sharpe Ratio: {market_sharpe}")
print(f"Strategy Sharpe Ratio: {strategy_sharpe}")

# Experiment with different moving averages (try 20-day and 50-day)
data['MA20'] = data['AAPL'].rolling(window=20).mean()
data['MA50'] = data['AAPL'].rolling(window=50).mean()

# Generate new signals
data['Signal'] = 0
data['Signal'][20:] = np.where(data['MA20'][20:] > data['MA50'][20:], 1, 0)

# Calculate positions based on the new signals
data['Position'] = data['Signal'].diff()

# Recalculate the returns
data['Market Return'] = data['AAPL'].pct_change()
data['Strategy Return'] = data['Market Return'] * data['Position'].shift(1)

# Cumulative returns
data['Market Cumulative Return'] = (1 + data['Market Return']).cumprod()
data['Strategy Cumulative Return'] = (1 + data['Strategy Return']).cumprod()

# Recalculate volatility and Sharpe ratio
market_volatility = data['Market Return'].std() * np.sqrt(252)
strategy_volatility = data['Strategy Return'].std() * np.sqrt(252)

market_sharpe = (data['Market Return'].mean() - 0) / data['Market Return'].std() * np.sqrt(252)
strategy_sharpe = (data['Strategy Return'].mean() - 0) / data['Strategy Return'].std() * np.sqrt(252)

# Print the updated Sharpe ratio and volatility
print(f"New Market Volatility: {market_volatility}")
print(f"New Strategy Volatility: {strategy_volatility}")
print(f"New Market Sharpe Ratio: {market_sharpe}")
print(f"New Strategy Sharpe Ratio: {strategy_sharpe}")

best_sharpe = -float('inf')
best_ma_short = None
best_ma_long = None

for short_window in range(5, 21, 5):  # Test short windows from 5 to 20 days
    for long_window in range(20, 61, 10):  # Test long windows from 20 to 60 days
        # Calculate moving averages
        data[f'MA{short_window}'] = data['AAPL'].rolling(window=short_window).mean()
        data[f'MA{long_window}'] = data['AAPL'].rolling(window=long_window).mean()

        # Generate signals with .iloc[] for positional slicing
        data.iloc[short_window:, data.columns.get_loc('Signal')] = np.where(
            data[f'MA{short_window}'][short_window:] > data[f'MA{long_window}'][short_window:], 1, 0
        )

        # Calculate positions and returns
        data['Position'] = data['Signal'].diff()
        data['Strategy Return'] = data['Market Return'] * data['Position'].shift(1)

        # Calculate Sharpe Ratio
        strategy_sharpe = (data['Strategy Return'].mean() - risk_free_rate) / data['Strategy Return'].std() * np.sqrt(252)

        # Store the best Sharpe ratio
        if strategy_sharpe > best_sharpe:
            best_sharpe = strategy_sharpe
            best_ma_short = short_window
            best_ma_long = long_window

print(f'Best Sharpe Ratio: {best_sharpe}')
print(f'Best Short MA: {best_ma_short} days')
print(f'Best Long MA: {best_ma_long} days')

# Calculate the moving averages
data['MA5'] = data['AAPL'].rolling(window=5).mean()
data['MA20'] = data['AAPL'].rolling(window=20).mean()

# Generate signals
data['Signal'] = 0
data['Signal'][5:] = np.where(data['MA5'][5:] > data['MA20'][5:], 1, 0)

# Calculate positions and strategy returns
data['Position'] = data['Signal'].diff()
data['Strategy Return'] = data['Market Return'] * data['Position'].shift(1)

# Calculate cumulative returns for both the market and your strategy
data['Market Cumulative Return'] = (1 + data['Market Return']).cumprod()
data['Strategy Cumulative Return'] = (1 + data['Strategy Return']).cumprod()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from itertools import product

# Function to calculate RSI manually
def calculate_rsi(data, window):
    delta = data['AAPL'].diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()

    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))

    return rsi

# Function to calculate trading signals based on multiple indicators (MA + RSI)
def multi_indicator_strategy(data, short_window, long_window, rsi_window, rsi_threshold_low, rsi_threshold_high):
    # Calculate Moving Averages
    data['MA_short'] = data['AAPL'].rolling(window=short_window).mean()
    data['MA_long'] = data['AAPL'].rolling(window=long_window).mean()

    # Calculate RSI (Relative Strength Index)
    data['RSI'] = calculate_rsi(data, rsi_window)

    # Generate buy/sell signals based on Moving Averages and RSI
    data['Signal'] = 0
    buy_condition = (data['MA_short'] > data['MA_long']) & (data['RSI'] < rsi_threshold_low)
    sell_condition = (data['MA_short'] < data['MA_long']) & (data['RSI'] > rsi_threshold_high)

    data.loc[buy_condition, 'Signal'] = 1
    data.loc[sell_condition, 'Signal'] = -1

    # Calculate positions (shift by 1 day to account for next-day trade execution)
    data['Position'] = data['Signal'].shift(1)

    # Calculate strategy returns
    data['Strategy Return'] = data['Market Return'] * data['Position']

    # Cumulative returns
    data['Market Cumulative Return'] = (1 + data['Market Return']).cumprod()
    data['Strategy Cumulative Return'] = (1 + data['Strategy Return']).cumprod()

    # Calculate Sharpe Ratio
    sharpe_ratio = data['Strategy Return'].mean() / data['Strategy Return'].std()

    return data, sharpe_ratio

# Function to optimize the strategy by maximizing the Sharpe Ratio
def optimize_strategy_sharpe(data, short_window_range, long_window_range, rsi_window_range, rsi_threshold_low_range, rsi_threshold_high_range):
    best_sharpe = -np.inf
    best_params = None
    results = []

    for short_window, long_window, rsi_window, rsi_low, rsi_high in product(short_window_range, long_window_range, rsi_window_range, rsi_threshold_low_range, rsi_threshold_high_range):
        if short_window < long_window:
            strategy_data, sharpe = multi_indicator_strategy(data.copy(), short_window, long_window, rsi_window, rsi_low, rsi_high)
            results.append((short_window, long_window, rsi_window, rsi_low, rsi_high, sharpe))
            if sharpe > best_sharpe:
                best_sharpe = sharpe
                best_params = (short_window, long_window, rsi_window, rsi_low, rsi_high)

    return best_params, results

# Plotting function for comparison
def plot_optimized_results(data, short_window, long_window, rsi_window, rsi_low, rsi_high):
    plt.figure(figsize=(12, 6))
    plt.plot(data['Market Cumulative Return'], label='Market Cumulative Return (Buy & Hold)', color='blue')
    plt.plot(data['Strategy Cumulative Return'], label=f'Strategy Cumulative Return (MA {short_window}/{long_window}, RSI {rsi_low}/{rsi_high})', color='orange')
    plt.title(f'Strategy vs Market: MA({short_window}, {long_window}), RSI({rsi_low}/{rsi_high})')
    plt.legend()
    plt.show()

# Main Execution
if __name__ == "__main__":
    # Set up the ranges for optimization
    short_window_range = range(5, 51, 5)        # MA Short window from 5 to 50
    long_window_range = range(20, 101, 5)       # MA Long window from 20 to 100
    rsi_window_range = range(10, 31, 5)         # RSI period from 10 to 30
    rsi_threshold_low_range = range(30, 40, 5)  # RSI low threshold from 30 to 40
    rsi_threshold_high_range = range(60, 80, 5) # RSI high threshold from 60 to 80

    # Optimize strategy
    best_params, results = optimize_strategy_sharpe(data, short_window_range, long_window_range, rsi_window_range, rsi_threshold_low_range, rsi_threshold_high_range)

    short_window_optimal, long_window_optimal, rsi_window_optimal, rsi_low_optimal, rsi_high_optimal = best_params

    # Print optimal parameters and Sharpe ratio
    print(f"Best Parameters: Short MA = {short_window_optimal}, Long MA = {long_window_optimal}, RSI Window = {rsi_window_optimal}, RSI Low = {rsi_low_optimal}, RSI High = {rsi_high_optimal}")

    # Apply the best strategy
    optimized_data, sharpe_optimal = multi_indicator_strategy(data, short_window_optimal, long_window_optimal, rsi_window_optimal, rsi_low_optimal, rsi_high_optimal)

    # Plot the optimized results
    plot_optimized_results(optimized_data, short_window_optimal, long_window_optimal, rsi_window_optimal, rsi_low_optimal, rsi_high_optimal)